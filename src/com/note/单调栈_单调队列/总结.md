好的，我们来详细讲解一下图片中这个非常经典且巧妙的算法——**「单调栈」**。这段代码用于解决“下一个更大元素”（Next Greater Element）问题。

### 算法目的

给定一个数组 `nums`，为数组中的每个元素找出其**下一个更大的元素**。即，对于每个元素 `nums[i]`，在数组中找到其**右边**第一个比它大的元素 `nums[j]`（`j > i`）。如果不存在，则通常用 -1 表示。

例如，对于数组 `[2, 1, 3]`：
- 2 的下一个更大元素是 3。
- 1 的下一个更大元素是 3。
- 3 的右边没有更大的元素，所以是 -1。
  结果应为 `[3, 3, -1]`。

---

### 算法核心思想：单调栈

这个算法的核心是维护一个**从栈底到栈顶单调递减的栈**（Monotonically Decreasing Stack）。栈里存放的是元素的**索引**，而不是元素本身的值。通过维护栈的单调性，我们可以高效地找到“下一个更大”的关系。

---

### 算法步骤拆解（逐行讲解）

让我们结合你提供的代码图片进行逐行分析：

1.  **`Stack<Integer> stack = new Stack();`**
    *   **作用**：初始化一个空栈。这个栈用于存放**尚未找到“下一个更大元素”的元素的索引**。

2.  **`for (int i = 0 ; i < nums.length ; i++) {`**
    *   **作用**：开始遍历数组中的每一个元素。`i` 是当前元素的索引。

3.  **`while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {`**
    *   **这是算法的核心逻辑**。它是一个循环条件，检查两件事：
        *   `!stack.isEmpty()`：栈不能为空。
        *   `nums[stack.peek()] < nums[i]`：**当前元素 `nums[i]` 是否大于栈顶索引所对应的元素**。
    *   **如果条件满足**，意味着一个关键的时刻到了：**当前元素 `nums[i]` 就是栈顶元素的下一个更大元素！**

4.  **`int top = stack.pop();`**
    *   **作用**：既然已经为栈顶元素找到了它的“下一个更大元素”，它的任务就完成了。我们将其索引从栈中弹出（移除）并保存在变量 `top` 中。

5.  **`//此时说明 nums[top]的下一个更大的元素为nums[i]`**
    *   **作用**：注释。这里就是处理结果的地方。在实际的完整代码中，这里会有一行代码将结果记录到一个答案数组中，例如：`result[top] = nums[i];`。

6.  **`}`** (结束 while 循环)
    *   **作用**：这个 `while` 循环会持续执行，直到当前元素 `nums[i]` 不再大于新的栈顶元素（即破坏了栈的单调递减性），或者栈为空。

7.  **`stack.push(i);`**
    *   **作用**：在经过上面的 `while` 循环处理后，当前元素 `nums[i]` 还没有找到它自己的“下一个更大元素”。所以，将它的索引 `i` 压入栈中，等待在后续的遍历中被处理。
    *   由于我们在压栈前弹出了所有比当前元素小的值，所以栈内的索引对应的元素值始终保持着**从栈底到栈顶单调递减**的顺序。

8.  **`}`** (结束 for 循环)

**遍历结束后**：栈中可能还会剩下一些索引。这些索引对应的元素，在它们的右边都没有找到更大的元素。在完整的代码中，需要再遍历一次栈，将这些位置在结果数组中设置为 -1。（有时也可以在初始化结果数组时全部设为 -1，这样没被覆盖的就是 -1）。

---

### 算法演示（举例说明）

让我们用一个简单的例子 `nums = [2, 1, 3]` 来模拟整个过程：

| 当前索引 `i` | 当前元素 `nums[i]` | 栈操作 (`stack`) | While 循环操作 | 解释 |
| :--- | :--- | :--- | :--- | :--- |
| 开始 | - | `[]` (空) | - | 初始化空栈 |
| `i=0` | `2` | `[0]` | 不进入 | `栈空，直接压入索引0` |
| `i=1` | `1` | `[0, 1]` | 不进入 | `nums[peek=0]=2 > 1`，不满足循环条件，直接压入索引1 |
| `i=2` | `3` | `[0]` -> `[]` -> `[2]` | **进入并执行两次** | **第一次循环**: `nums[peek=1]=1 < 3` -> **弹出1**，记录 `result[1] = 3`<br>**第二次循环**: `nums[peek=0]=2 < 3` -> **弹出0**，记录 `result[0] = 3`<br>栈空，退出循环，压入当前索引 `2` |

最终，栈中剩余 `[2]`，对应元素 `3` 没有下一个更大元素，所以 `result[2] = -1`。
最终结果为：`[3, 3, -1]`。

---

### 为什么这个算法高效？

-   **暴力解法**需要两层循环，时间复杂度为 O(n²)。
-   **单调栈解法**的每个元素最多被压入和弹出栈各一次，时间复杂度为 **O(n)**，效率非常高。

### 总结

这个算法的精髓在于：

1.  **单调性**：维护一个**单调递减栈**，栈中的元素代表了“尚未被解决的候选者”。
2.  **触发时机**：当遇到一个比栈顶元素大的值时，这个值就是一个“触发器”，可以一次性解决栈中所有比它小的元素的问题。
3.  **结果记录**：在弹出栈顶元素的那一刻，当前遍历到的元素就是它的答案。

这是一个非常优美和高效的算法，是解决“下一个更大元素”系列问题的标准模板，也广泛应用于其他涉及单调性的题目中（如：接雨水、柱状图中最大的矩形等）。