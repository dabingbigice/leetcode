package com.代码随想录.动态规划;

import java.util.Arrays;

public class 不同的二叉搜索树_96 {
    /**
     * 计算由 n 个节点组成的二叉搜索树有多少种不同的结构。
     * 使用动态规划求解，状态定义：dp[i] 表示 i 个节点能生成的二叉搜索树数量。
     * 核心思想：对于每个节点数 i，依次让每个节点 j 作为根节点，则左子树有 j-1 个节点，右子树有 i-j 个节点。
     * 状态转移方程：dp[i] = Σ(dp[j-1] * dp[i-j])，其中 j 从 1 到 i。
     *
     * @param n 节点数量
     * @return 返回不同结构的二叉搜索树个数
     */
    public int numTrees(int n) {
        // dp数组：dp[i]表示i个节点能生成的不同二叉搜索树的数量
        int[] dp = new int[n + 1];

        // 基础情况：0个节点只有空树一种情况，1个节点只有单节点树一种情况
        dp[0] = 1; // 空树也算一种结构
        dp[1] = 1; // 只有一个节点时只有一种结构

        // 外层循环：计算从2个节点到n个节点的BST数量
        for (int i = 2; i <= n; i++) {
            // 内层循环：遍历每个可能的根节点位置j（从1到i）
            for (int j = 1; j <= i; j++) {
                // 当j为根时：左子树有j-1个节点，右子树有i-j个节点
                // 左右子树的组合数相乘，并累加到dp[i]
                //简单来说，dp[j-1]代表的是，当您选定一个根节点后，其左子树的所有可能结构数量。
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        // 打印dp数组（调试用，实际使用时可以删除）
        System.out.println(Arrays.toString(dp));

        // 返回n个节点的二叉搜索树数量
        return dp[n];
    }
}
