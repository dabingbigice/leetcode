package com.代码随想录.动态规划;

public class 买卖股票的最佳时机Ⅲ_123 {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        // 边界判断：如果价格数组为空，直接返回0
        if (prices.length == 0) return 0;
        /*
         * 定义 5 种状态:
         * 0: 没有操作（初始状态）
         * 1: 第一次买入（持有股票）
         * 2: 第一次卖出（已卖出第一次买入的股票）
         * 3: 第二次买入（持有股票）
         * 4: 第二次卖出（已卖出第二次买入的股票）
         * 使用二维DP数组：dp[i][j] 表示第i天处于状态j时的最大利润
         */
        int[][] dp = new int[len][5];
        // 初始化第0天（第一天）的各种状态
        dp[0][1] = -prices[0];  // 第一天买入股票，利润为负的股价
        // 初始化第二次买入的状态：允许同一天完成第一次卖出后立即进行第二次买入
        // 这是关键点，确保算法能正确处理只进行一次交易的情况
        dp[0][3] = -prices[0];
        for (int i = 1; i < len; i++) {
            // 状态1：第一次买入 = 保持前一天第一次买入状态 或 当天进行第一次买入
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            // 状态2：第一次卖出 = 保持前一天第一次卖出状态 或 基于第一次买入状态在当天卖出
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            // 状态3：第二次买入 = 保持前一天第二次买入状态 或 用第一次卖出的利润在当天进行第二次买入
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            // 状态4：第二次卖出 = 保持前一天第二次卖出状态 或 基于第二次买入状态在当天卖出
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        // 返回最终状态：第二次卖出后的最大利润
        // 这个值包含了最多两笔交易的最佳结果（可能优于单笔交易或零交易）
        return dp[len - 1][4];
    }
}
